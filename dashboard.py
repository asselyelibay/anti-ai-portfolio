# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10xleiHcwbx-mAEfzjSVTfVOWDG5qSbBO
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from scipy.optimize import minimize
import yfinance as yf

st.set_page_config(page_title="Anti-AI Portfolio", layout="wide")

# TITLE
st.title("üõ°Ô∏è Anti-AI Bubble Portfolio Dashboard")
st.markdown("**Defensive Multi-Asset Strategy | Low Correlation to Tech**")

# SIDEBAR
st.sidebar.header("Portfolio Configuration")

default_tickers = ["KO","PEP","PG","JNJ","ABT","SO","DUK","XOM","CVX","PLD","AMT","AGG","TLT","GLD"]
tickers = st.sidebar.multiselect("Select Assets", options=default_tickers, default=default_tickers[:8])
start_date = st.sidebar.date_input("Start Date", value=pd.to_datetime("2020-01-01"))
risk_free = st.sidebar.slider("Risk-Free Rate (%)", 0.0, 5.0, 2.0, 0.1) / 100

# LOAD DATA
@st.cache_data
def load_data(tickers, start):
    data = yf.download(tickers, start=start, progress=False)["Close"]
    return data.ffill().dropna(how='all')

if len(tickers) > 1:
    with st.spinner("Loading data..."):
        data = load_data(tickers, start_date)
        returns = data.pct_change().dropna()

    # Annualized metrics
    mu = returns.mean() * 252
    cov = returns.cov() * 252

    # OPTIMIZATION
    n = len(tickers)
    w0 = np.ones(n) / n
    bounds = [(0.015, 0.15)] * n

    def portfolio_vol(w):
        return np.sqrt(np.dot(w.T, np.dot(cov, w)))

    def negative_sharpe(w):
        ret = np.dot(w, mu)
        vol = portfolio_vol(w)
        return -(ret - risk_free) / vol

    # Max Sharpe
    max_sharpe_result = minimize(
        negative_sharpe, w0, method="SLSQP",
        bounds=bounds,
        constraints=[{"type": "eq", "fun": lambda w: np.sum(w) - 1}],
        options={'maxiter': 1000}
    )

    # Min Vol
    min_vol_result = minimize(
        portfolio_vol, w0, method="SLSQP",
        bounds=bounds,
        constraints=[{"type": "eq", "fun": lambda w: np.sum(w) - 1}],
        options={'maxiter': 1000}
    )

    if max_sharpe_result.success:
        w_sharpe = max_sharpe_result.x
        w_min = min_vol_result.x

        ret_sharpe = np.dot(w_sharpe, mu)
        vol_sharpe = portfolio_vol(w_sharpe)
        sharpe = (ret_sharpe - risk_free) / vol_sharpe

        ret_min = np.dot(w_min, mu)
        vol_min = portfolio_vol(w_min)

        # KPIs
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìà Annual Return", f"{ret_sharpe*100:.2f}%")
        with col2:
            st.metric("üìä Volatility", f"{vol_sharpe*100:.2f}%")
        with col3:
            st.metric("‚≠ê Sharpe Ratio", f"{sharpe:.3f}")
        with col4:
            port_rets = (returns * w_sharpe).sum(axis=1)
            var_95 = np.percentile(port_rets, 5)
            st.metric("‚ö†Ô∏è VaR 95%", f"{var_95*100:.2f}%")

        # ROW 1: CHARTS
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("üìä Portfolio Allocation")
            weights_df = pd.DataFrame({
                'Asset': tickers,
                'Weight': w_sharpe * 100
            }).sort_values('Weight', ascending=False)

            fig = px.pie(weights_df, values='Weight', names='Asset',
                         title="Max Sharpe Portfolio")
            st.plotly_chart(fig, use_container_width=True)

        with col2:
            st.subheader("üìà Efficient Frontier")

            # Generate frontier
            target_returns = np.linspace(ret_min * 0.9, ret_sharpe * 1.1, 30)
            frontier_vol = []

            for r in target_returns:
                def ret_constraint(w):
                    return np.dot(w, mu) - r

                res = minimize(
                    portfolio_vol, w0, method="SLSQP",
                    bounds=bounds,
                    constraints=[
                        {"type": "eq", "fun": lambda w: np.sum(w) - 1},
                        {"type": "eq", "fun": ret_constraint}
                    ],
                    options={'maxiter': 500}
                )
                frontier_vol.append(res.fun if res.success else np.nan)

            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=frontier_vol, y=target_returns,
                mode='lines', name='Efficient Frontier',
                line=dict(color='blue', width=2)
            ))
            fig.add_trace(go.Scatter(
                x=[vol_sharpe], y=[ret_sharpe],
                mode='markers', name='Max Sharpe',
                marker=dict(size=15, color='red', symbol='star')
            ))
            fig.add_trace(go.Scatter(
                x=[vol_min], y=[ret_min],
                mode='markers', name='Min Vol',
                marker=dict(size=12, color='green', symbol='diamond')
            ))
            fig.update_layout(
                xaxis_title="Volatility",
                yaxis_title="Return",
                title="Risk-Return Tradeoff"
            )
            st.plotly_chart(fig, use_container_width=True)

        # ROW 2: PERFORMANCE
        st.subheader("üìâ Cumulative Performance")

        port_cumret = (1 + (returns * w_sharpe).sum(axis=1)).cumprod()

        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=port_cumret.index, y=(port_cumret - 1) * 100,
            mode='lines', name='Portfolio',
            line=dict(color='green', width=2)
        ))
        fig.update_layout(
            xaxis_title="Date",
            yaxis_title="Cumulative Return (%)",
            title="Portfolio Growth Since Inception",
            hovermode='x unified'
        )
        st.plotly_chart(fig, use_container_width=True)

        # ROW 3: TABLES
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("üéØ Portfolio Weights")
            st.dataframe(
                weights_df.style.format({'Weight': '{:.2f}%'}),
                hide_index=True,
                use_container_width=True
            )

        with col2:
            st.subheader("üìä Risk Metrics")
            cvar_95 = port_rets[port_rets <= var_95].mean()
            cumulative = (1 + port_rets).cumprod()
            rolling_max = cumulative.cummax()
            drawdown = cumulative / rolling_max - 1
            max_dd = drawdown.min()

            metrics = pd.DataFrame({
                'Metric': ['Annual Return', 'Annual Volatility', 'Sharpe Ratio',
                          'VaR 95%', 'CVaR 95%', 'Max Drawdown'],
                'Value': [f"{ret_sharpe*100:.2f}%", f"{vol_sharpe*100:.2f}%",
                         f"{sharpe:.3f}", f"{var_95*100:.2f}%",
                         f"{cvar_95*100:.2f}%", f"{max_dd*100:.2f}%"]
            })
            st.dataframe(metrics, hide_index=True, use_container_width=True)

    else:
        st.error("‚ùå Optimization failed. Try selecting different assets or adjusting parameters.")

else:
    st.warning("‚ö†Ô∏è Please select at least 2 assets from the sidebar")

# FOOTER
st.markdown("---")
st.markdown("**Developed by Assel Yelibay** | I√âSEG School of Management")
